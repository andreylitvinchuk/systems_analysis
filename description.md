Логично начать разработки системы в монолите, но с четко обозначенными границами контекстов и строгими контрактами между модулями, имплементирующими отдельный контексты. 

Почему:
1. Монолит позволит потратить минимум времени на на старт и сократить ресурсы на настройку инфраструктуры
2. Если где-то ошибочно проведем границы контекстов - в монолите отрефачить и провести новые границы будет проще
3. Нагрузка ожидается небольшая. первым узким местом при нагрузке обычно становится БД, но с ожидаемыми нагрузками до этого далеко

При всех плюсах монолита надо ввести ограничения, чтобы его в случае чего было легко распиливать
1. отдельные модули - дадут возможность выноса функционала в сервисы в будущем, если это потребуется
    Модули должны иметь публичные интерфейсы для получения данных, если использовать данные из-за пределов контекста с помощью интерфейсов модуля, а не просто тянуть из базы - проблем с разделением на сервисы в дальнейшем быть не должно, т.к. сможем просто поменять внутренние вызовы и события на grpc и kafka
2. Событийную модель можно сделать с помощью паттерна listener, и фоновых воркеров. Воркеры должны иметь контракты с необходимыми для их работы данными. Тогда будет легко потом заменить на кафку если потребуется. 
3. Состав разработчиков - не больше одной команды на один bounded context
4. В качестве идентификаторов сущностей используем uuid-ы - будет проще выносить части из монолита. 
    на промежуточных этапах придется продолжать стримить данные в монолит из сервисов, т.к. аналитика скорей всего завяжется на данные в монолите и будет строить свои отчеты ходя в своюю реплику. если в качестве идентификаторов и связей будут инкрементальные id - это может стать проблемой, поэтому правильнее было бы сразу использовать uuid-ы


